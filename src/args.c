/*
 * Copyright (c) 2022 - 2023 OSM Group @ HPI, University of Potsdam
 */

#include "./args.h"

#include <string.h>

#include "./util.h"
#include "./smog-trace-converter.h"

static const char doc[] = "a post-processing tool for traces generated by smog-meter";
static const char args_doc[] = "TRACEFILE OUTFILE";

static struct argp_option options[] = {
    { "output-format", 'o', "FORMAT", 0,
      "the output format to produce. smog-trace-converter tries to guess the output "
      "format you want from the file extension of the output file, but this flag can "
      "override this guess with an explicit choice.\nOptions are: parquet, png, "
      "png-frames and histogram.", 0 },
    { "page-size", 'S', "SIZE", 0,
      "override the default system page size for size reporting", 0 },
    { "vma", 'f', "NAME", 0,
      "limit the output to a single VMA", 0 },
    { "verbose", 'v', 0, 0,
      "show additional output, pass multiple times for even more output", 1 },
    { 0 }
};

static error_t parse_opt(int key, char *arg, struct argp_state *state) {
    struct arguments *arguments = (struct arguments*)state->input;

    switch (key) {
        case 'o':
            if (!strcmp(arg, "parquet")) {
                arguments->output_format = OUTPUT_PARQUET;
            } else if (!strcmp(arg, "png")) {
                arguments->output_format = OUTPUT_PNG;
            } else if (!strcmp(arg, "png-frames")) {
                arguments->output_format = OUTPUT_PNG_FRAMES;
            } else if (!strcmp(arg, "histogram")) {
                arguments->output_format = OUTPUT_HISTOGRAM;
            } else {
                argp_error(state, "unsupported output format: %s", arg);
            }
            break;
        case 'f':
            arguments->filter_vma = arg;
            break;
        case 'S':
            errno = 0;
            arguments->page_size = parse_size_string(arg);
            if (errno != 0)
                argp_failure(state, 1, errno, "invalid page-size: %s", arg);
            break;
        case 'v':
            arguments->verbose++;
            break;

        case ARGP_KEY_ARG:
            switch (state->arg_num) {
                case 0:
                    arguments->tracefile = arg;
                    break;
                case 1:
                    arguments->output_file = arg;
                    break;
                default:
                    argp_usage(state);
                    break;
            }
            break;

        case ARGP_KEY_END:
            if (state->arg_num < 2)
                argp_usage(state);

            // try to guess output format from extension
            if (arguments->output_format == OUTPUT_UNKNOWN) {
                char *ext = strrchr(arguments->output_file, '.');
                if (ext != NULL && !strcmp(ext, ".parquet")) {
                    arguments->output_format = OUTPUT_PARQUET;
                } else if (ext != NULL && !strcmp(ext, ".png")) {
                    if (strstr(arguments->output_file, "%s")) {
                        arguments->output_format = OUTPUT_PNG_FRAMES;
                    } else {
                        arguments->output_format = OUTPUT_PNG;
                    }
                } else if (ext != NULL && !strcmp(ext, ".txt")) {
                    arguments->output_format = OUTPUT_HISTOGRAM;
                }
            }

            if (arguments->output_format == OUTPUT_UNKNOWN) {
                argp_failure(state, 1, 0, "unable to guess output format from %s.\n"
                             "hint: check the file extension on your output file or "
                             "specify the output format explicitly.",
                             arguments->output_file);
            }
            break;

        default:
            return ARGP_ERR_UNKNOWN;
    }

    return 0;
}

struct argp argp = { options, parse_opt, args_doc, doc, NULL, NULL, NULL };
